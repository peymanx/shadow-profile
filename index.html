<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Device Fingerprint with Stable and Dynamic Hash</title>
<style>
  body { font-family: Arial, sans-serif; margin: 40px; background: #f0f0f0; direction: ltr; }
  h1, h2 { color: #333; }
  .fingerprint { background: #fff; padding: 20px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); margin-top: 30px; }
  .item { margin-bottom: 10px; }
  .label { font-weight: bold; color: #555; }
  #hashStable, #hashDynamic {
    font-family: monospace; 
    background: #222; 
    color: #0f0; 
    padding: 20px; 
    border-radius: 12px; 
    font-size: 1.6em; 
    word-break: break-all;
    user-select: all;
    text-align: center;
    margin-bottom: 20px;
    transition: color 0.3s ease;
  }
  .hash-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    max-width: 700px;
  }
  .canvas-image {
    margin-top: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
    max-width: 180px;
    height: auto;
  }
</style>
</head>
<body>

<h1>üîë Device Fingerprint Hashes</h1>
<div class="hash-container">
  <div>
    <h2>üõ°Ô∏è Stable Hash (Does NOT change on window resize)</h2>
    <div id="hashStable">Calculating...</div>
  </div>
  <div>
    <h2>üéØ Dynamic Hash (Changes on window resize)</h2>
    <div id="hashDynamic">Calculating...</div>
  </div>
</div>

<h1>üß© Comprehensive Device Fingerprint Info</h1>
<div class="fingerprint" id="fingerprint"></div>

<script>
// --- Data storage ---
const fingerprintElements = {};
const stableFingerprintData = [];
const dynamicFingerprintData = [];

// Helper to add/update items in fingerprint display and arrays
function addOrUpdateItem(label, value, emoji = "", toStable = true, toDynamic = true, extraHTML = "") {
    const container = document.getElementById("fingerprint");

    if (!fingerprintElements[label]) {
        const div = document.createElement("div");
        div.className = "item";
        fingerprintElements[label] = div;
        container.appendChild(div);
    }

    const em = emoji ? emoji + " " : "";
    fingerprintElements[label].innerHTML = `<span class="label">${em}${label}:</span> ${value} ${extraHTML}`;

    // Update stable array
    if (toStable) {
        const idx = stableFingerprintData.findIndex(item => item.startsWith(label + ":"));
        if (idx >= 0) stableFingerprintData[idx] = `${label}:${value}`;
        else stableFingerprintData.push(`${label}:${value}`);
    }

    // Update dynamic array
    if (toDynamic) {
        const idx = dynamicFingerprintData.findIndex(item => item.startsWith(label + ":"));
        if (idx >= 0) dynamicFingerprintData[idx] = `${label}:${value}`;
        else dynamicFingerprintData.push(`${label}:${value}`);
    }
}

// Collect stable info (doesn't depend on window size or dynamic data)
function collectStableInfo() {
    addOrUpdateItem("User-Agent", navigator.userAgent, "ü§ñ", true, false);
    addOrUpdateItem("Browser Language", navigator.language, "üåê", true, false);
    addOrUpdateItem("Preferred Languages", navigator.languages ? navigator.languages.join(", ") : "Unknown", "üó£Ô∏è", true, false);
    addOrUpdateItem("Time Zone", Intl.DateTimeFormat().resolvedOptions().timeZone, "‚è∞", true, false);
    addOrUpdateItem("Screen Resolution", `${screen.width} x ${screen.height}`, "üñ•Ô∏è", true, false);
    addOrUpdateItem("Available Screen Resolution", `${screen.availWidth} x ${screen.availHeight}`, "üì∫", true, false);
    addOrUpdateItem("Color Depth", screen.colorDepth, "üé®", true, false);
    addOrUpdateItem("Pixel Depth", screen.pixelDepth, "üü¶", true, false);
    addOrUpdateItem("Cookies Enabled", navigator.cookieEnabled, "üç™", true, false);
    addOrUpdateItem("Local Storage Supported", (() => {
        try { localStorage.setItem('test','1'); localStorage.removeItem('test'); return "Yes"; }
        catch(e){ return "No"; }
    })(), "üíæ", true, false);
    addOrUpdateItem("Session Storage Supported", (() => {
        try { sessionStorage.setItem('test','1'); sessionStorage.removeItem('test'); return "Yes"; }
        catch(e){ return "No"; }
    })(), "üóÑÔ∏è", true, false);
    addOrUpdateItem("IndexedDB Supported", !!window.indexedDB ? "Yes" : "No", "üß©", true, false);
    addOrUpdateItem("Do Not Track", navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack || "Unset", "üö´", true, false);
    
    function getPlugins() {
        if (navigator.plugins) {
            let plugins = [];
            for (let i=0; i < navigator.plugins.length; i++) {
                plugins.push(navigator.plugins[i].name);
            }
            return plugins.length ? plugins.join(", ") : "No Plugins";
        }
        return "Not supported";
    }
    addOrUpdateItem("Plugins", getPlugins(), "üîå", true, false);
    
    function getMimeTypes() {
        if (navigator.mimeTypes) {
            let mimes = [];
            for (let i=0; i < navigator.mimeTypes.length; i++) {
                mimes.push(navigator.mimeTypes[i].type);
            }
            return mimes.length ? mimes.join(", ") : "No MIME Types";
        }
        return "Not supported";
    }
    addOrUpdateItem("MIME Types", getMimeTypes(), "üìÑ", true, false);

    addOrUpdateItem("Screen Orientation", screen.orientation ? screen.orientation.type : "Not supported", "üì±", true, false);
    addOrUpdateItem("CPU Cores", navigator.hardwareConcurrency || "Unknown", "üß†", true, false);
    addOrUpdateItem("Device Memory (GB)", navigator.deviceMemory || "Unknown", "üõ†Ô∏è", true, false);
    addOrUpdateItem("Touch Support", ('ontouchstart' in window || navigator.maxTouchPoints > 0) ? "Yes" : "No", "‚úã", true, false);
    addOrUpdateItem("Platform", navigator.platform || "Unknown", "üíª", true, false);

    // Canvas fingerprint goes into stable data only
    const canvasFingerprint = getCanvasFingerprint();
    addOrUpdateItem("Canvas Fingerprint", canvasFingerprint, "üé®", true, false, `<br><img class="canvas-image" src="${canvasFingerprint}" alt="Canvas Fingerprint Image" />`);
}

// Collect dynamic info (changes on window resize)
function collectDynamicInfo() {
    addOrUpdateItem("Window Inner Size", `${window.innerWidth} x ${window.innerHeight}`, "üìê", false, true);
}

// Canvas Fingerprint generation
function getCanvasFingerprint() {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    ctx.textBaseline = "top";
    ctx.font = "16px Arial";
    ctx.fillStyle = "#f60";
    ctx.fillRect(125,1,62,20);
    ctx.fillStyle = "#069";
    ctx.fillText("Fingerprint Test", 2, 15);
    ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
    ctx.fillText("Fingerprint Test", 4, 17);
    return canvas.toDataURL();
}

// Battery info async (add to both stable and dynamic)
function addBatteryInfo() {
    if (navigator.getBattery) {
        navigator.getBattery().then(function(battery) {
            // Adding battery info both to stable (mostly stable) and dynamic (charging status can change)
            addOrUpdateItem("Battery Level", (battery.level * 100).toFixed(0) + "%", "üîã", true, true);
            addOrUpdateItem("Charging", battery.charging ? "Yes" : "No", "‚ö°", true, true);
            addOrUpdateItem("Charging Time (sec)", battery.chargingTime, "‚è≥", true, true);
            addOrUpdateItem("Discharging Time (sec)", battery.dischargingTime, "‚åõ", true, true);
            finalizeHashes();
        });
    } else {
        addOrUpdateItem("Battery Status", "Not supported", "üîã", true, true);
        finalizeHashes();
    }
}

// SHA-256 hashing function
async function sha256(str) {
    const buf = new TextEncoder("utf-8").encode(str);
    const hashBuffer = await crypto.subtle.digest("SHA-256", buf);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
}

// Calculate & display both hashes
async function finalizeHashes() {
    const stableCombined = stableFingerprintData.join("\n");
    const dynamicCombined = stableFingerprintData.concat(dynamicFingerprintData).join("\n");

    const [stableHash, dynamicHash] = await Promise.all([
        sha256(stableCombined),
        sha256(dynamicCombined)
    ]);

    const stableDiv = document.getElementById("hashStable");
    const dynamicDiv = document.getElementById("hashDynamic");

    stableDiv.textContent = stableHash;
    dynamicDiv.textContent = dynamicHash;

    // Random color for dynamic hash to emphasize change
    const colors = ['#0f0', '#ff0', '#0ff', '#f0f', '#f00', '#00f', '#ffa500'];
    dynamicDiv.style.color = colors[Math.floor(Math.random() * colors.length)];
    stableDiv.style.color = "#0f0";  // Stable is always green
}

// Initialize all info
function init() {
    collectStableInfo();
    collectDynamicInfo();
    addBatteryInfo();
    finalizeHashes();
}

// Update dynamic info and dynamic hash on window resize
window.addEventListener('resize', () => {
    collectDynamicInfo();
    finalizeHashes();
});

// Run on load
init();

</script>

</body>
</html>
